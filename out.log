Academic license - for non-commercial use only
Academic license - for non-commercial use only
Academic license - for non-commercial use only
Academic license - for non-commercial use only
[ logger ](replanning.jl-620): REPLANNING: Stage 1
[ logger ](task_assignment_solvers.jl-1117): Assignment: Adding edges 
	GO(1,1->1) → COLLECT(1,1,1)
	GO(1,4->8) → COLLECT(1,2,8)

[ logger ](path_planning.jl-386): moved 4 to closed set, moved [2] to active set
[ logger ](path_planning.jl-386): moved 2 to closed set, moved [5] to active set
[ logger ](path_planning.jl-386): moved 20 to closed set, moved [9] to active set
[ logger ](path_planning.jl-386): moved 9 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 19 to closed set, moved [10] to active set
[ logger ](path_planning.jl-386): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 3 to closed set, moved [1] to active set
[ logger ](path_planning.jl-386): moved 1 to closed set, moved [6] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([1, 4, 9, 10, 2, 3, 19, 20])
	active_set:   Set([5, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =    5 => GO(1,1->1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10   
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,1->1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 5 to closed set, moved [11] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 10

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([1, 4, 9, 10, 2, 3, 19, 5, 20])
	active_set:   Set([11, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   11 => COLLECT(1,1,1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10   
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,1,1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 11 to closed set, moved [12] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 10

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([1, 4, 9, 10, 2, 3, 19, 11, 5, 20])
	active_set:   Set([6, 12])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   12 => CARRY(1,1,1->4)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10   
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,1,1->4)
    cache.tF[v]: 13
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=11), q_cost = (0.0, 0.0, 3.0, 2.0, -11.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=12), q_cost = (0.0, 0.0, 3.0, 1.0, -12.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=13), q_cost = (0.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 12 to closed set, moved [13] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 13

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 9, 10, 19, 4, 3, 5, 20, 12, 1])
	active_set:   Set([13, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   13 => DEPOSIT(1,1,4)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,1,4)
    cache.tF[v]: 13
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=4,t=13), q_cost = (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 13 to closed set, moved [7, 14] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 13

[ logger ](path_planning.jl-386): moved 7 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 12, 1])
	active_set:   Set([14, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   14 => GO(1,4->8)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,4->8)
    cache.tF[v]: 14
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=4,t=13), q_cost = (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=8,t=14), q_cost = (0.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-386): moved 14 to closed set, moved [15] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 14

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 12, 1])
	active_set:   Set([15, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   15 => COLLECT(1,2,8)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,2,8)
    cache.tF[v]: 14
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=8,t=14), q_cost = (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 15 to closed set, moved [16] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 14

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([16, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   16 => CARRY(1,2,8->6)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,2,8->6)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=8,t=14), q_cost = (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=7,t=15), q_cost = (0.0, 0.0, 6.0, 1.0, -15.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=6,t=16), q_cost = (0.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 3
[ logger ](path_planning.jl-386): moved 16 to closed set, moved [17] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([17, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   17 => DEPOSIT(1,2,6)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,2,6)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=16), q_cost = (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 17 to closed set, moved [8, 18] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](path_planning.jl-386): moved 8 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6, 18])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   18 => GO(1,6->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,6->-1)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 16
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=16), q_cost = (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 16. Extending terminal node GO(1,6->-1) to 16
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 16. maximum(cache.tF) = 16
[ logger ](path_planning.jl-386): moved 18 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6])
	node_queue:   PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 16
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 10. Extending terminal node GO(2,13->-1) to 16
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 16. maximum(cache.tF) = 16
[ logger ](path_planning.jl-386): moved 6 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 16, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](path_planning.jl-386): moved 4 to closed set, moved [2] to active set
[ logger ](path_planning.jl-386): moved 2 to closed set, moved [5] to active set
[ logger ](path_planning.jl-386): moved 20 to closed set, moved [9] to active set
[ logger ](path_planning.jl-386): moved 9 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 19 to closed set, moved [10] to active set
[ logger ](path_planning.jl-386): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 3 to closed set, moved [1] to active set
[ logger ](path_planning.jl-386): moved 1 to closed set, moved [6] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 9, 10, 19, 4, 3, 20, 1])
	active_set:   Set([5, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =    5 => GO(1,1->1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10   
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,1->1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 5 to closed set, moved [11] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 10

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 9, 10, 19, 4, 3, 5, 20, 1])
	active_set:   Set([11, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   11 => COLLECT(1,1,1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10   
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,1,1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 11 to closed set, moved [12] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 10

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 9, 10, 19, 4, 3, 5, 20, 1])
	active_set:   Set([6, 12])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   12 => CARRY(1,1,1->4)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10   
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,1,1->4)
    cache.tF[v]: 13
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=11), q_cost = (0.0, 0.0, 3.0, 2.0, -11.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=12), q_cost = (0.0, 0.0, 3.0, 1.0, -12.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=13), q_cost = (0.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 12 to closed set, moved [13] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 13

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 9, 10, 19, 4, 3, 5, 20, 12, 1])
	active_set:   Set([13, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   13 => DEPOSIT(1,1,4)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,1,4)
    cache.tF[v]: 13
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=4,t=13), q_cost = (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 13 to closed set, moved [7, 14] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 13

[ logger ](path_planning.jl-386): moved 7 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 12, 1])
	active_set:   Set([14, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   14 => GO(1,4->8)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,4->8)
    cache.tF[v]: 14
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=4,t=13), q_cost = (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=8,t=14), q_cost = (0.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-386): moved 14 to closed set, moved [15] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 14

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 12, 1])
	active_set:   Set([15, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   15 => COLLECT(1,2,8)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,2,8)
    cache.tF[v]: 14
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=8,t=14), q_cost = (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 15 to closed set, moved [16] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 14

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([16, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   16 => CARRY(1,2,8->6)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,2,8->6)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=8,t=14), q_cost = (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=7,t=15), q_cost = (0.0, 0.0, 6.0, 1.0, -15.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=6,t=16), q_cost = (0.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 3
[ logger ](path_planning.jl-386): moved 16 to closed set, moved [17] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([17, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =   17 => DEPOSIT(1,2,6)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,2,6)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=16), q_cost = (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 17 to closed set, moved [8, 18] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](path_planning.jl-386): moved 8 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6, 18])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   18 => GO(1,6->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,6->-1)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 16
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=16), q_cost = (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 16. Extending terminal node GO(1,6->-1) to 16
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 16. maximum(cache.tF) = 16
[ logger ](path_planning.jl-386): moved 18 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6])
	node_queue:   PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
	tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
	slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
	              [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
	              [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 16
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 10. Extending terminal node GO(2,13->-1) to 16
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 16. maximum(cache.tF) = 16
[ logger ](path_planning.jl-386): moved 6 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 16
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 16, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](cbs.jl-31): CBS: iter 0 - node Int64[] - Current paths: 
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]

[ logger ](cbs.jl-36): CBS: constraints in node Int64[]: 

[ logger ](cbs.jl-50): Optimal solution found by CBS! Cost = (29.0, 0.0, 6.0, 0.0, -26.0)
[ logger ](pc_tapf_solvers.jl-558): NBS: Reached 1-iteration limit.
[ logger ](replanning.jl-627): Stage 1 - route planner iterations: 0
[ logger ](replanning.jl-620): REPLANNING: Stage 2
[ logger ](task_assignment_solvers.jl-1117): Assignment: Adding edges 
	GO(1,6->13) → COLLECT(1,3,13)
	GO(1,1->16) → COLLECT(1,4,16)

[ logger ](path_planning.jl-386): moved 1 to closed set, moved [2] to active set
[ logger ](path_planning.jl-386): moved 2 to closed set, moved [7] to active set
[ logger ](path_planning.jl-386): moved 20 to closed set, moved [10] to active set
[ logger ](path_planning.jl-386): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 3 to closed set, moved [5] to active set
[ logger ](path_planning.jl-386): moved 5 to closed set, moved [4] to active set
[ logger ](path_planning.jl-386): moved 4 to closed set, moved [6] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([20, 4, 10, 2, 3, 5, 1])
	active_set:   Set([7, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2    8   15    0    8    5    5    8    8   14   14   15   15    0]
	tF:           [    0    2    0   18   10   18    5    8   15    0    8    5    8    8   14   14   15   15   15    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  5.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    7 => GO(1,6->13)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,6->13)
    cache.tF[v]: 5
    maximum(env.cache.tF): 18

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=18), q_cost = (18.0, 0.0, 6.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=5,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=9,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=13,t=21), q_cost = (16.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 7 to closed set, moved [12] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([20, 4, 7, 10, 2, 3, 5, 1])
	active_set:   Set([6, 12])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   12 => COLLECT(1,3,13)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,3,13)
    cache.tF[v]: 21
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 12 to closed set, moved [13] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([20, 4, 7, 10, 2, 3, 5, 12, 1])
	active_set:   Set([13, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   13 => CARRY(1,3,13->1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,3,13->1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=9,t=22), q_cost = (0.0, 0.0, 12.0, 2.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=5,t=23), q_cost = (0.0, 0.0, 12.0, 1.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=1,t=24), q_cost = (0.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 13 to closed set, moved [14] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([20, 4, 7, 10, 13, 2, 3, 5, 12, 1])
	active_set:   Set([14, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   14 => DEPOSIT(1,3,1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,3,1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 14 to closed set, moved [8, 15] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](path_planning.jl-386): moved 8 to closed set, moved [11] to active set
[ logger ](path_planning.jl-386): moved 11 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 12, 1])
	active_set:   Set([15, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   15 => GO(1,1->16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,1->16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=25), q_cost = (0.0, 0.0, 18.0, 5.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=26), q_cost = (0.0, 0.0, 18.0, 4.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=27), q_cost = (0.0, 0.0, 18.0, 3.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=8,t=28), q_cost = (0.0, 0.0, 18.0, 2.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=12,t=29), q_cost = (0.0, 0.0, 18.0, 1.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=16,t=30), q_cost = (0.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](path_planning.jl-386): moved 15 to closed set, moved [16] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([16, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   16 => COLLECT(1,4,16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,4,16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 16 to closed set, moved [17] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([17, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   17 => CARRY(1,4,16->15)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,4,16->15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=15,t=31), q_cost = (0.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-386): moved 17 to closed set, moved [18] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6, 18])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   18 => DEPOSIT(1,4,15)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,4,15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 18 to closed set, moved [9, 19] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](path_planning.jl-386): moved 9 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([19, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   19 => GO(1,15->-1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,15->-1)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 31. Extending terminal node GO(1,15->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-386): moved 19 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6])
	node_queue:   PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 18
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=18), q_cost = (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 18. Extending terminal node GO(2,13->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-386): moved 6 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 31, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](path_planning.jl-386): moved 1 to closed set, moved [2] to active set
[ logger ](path_planning.jl-386): moved 2 to closed set, moved [7] to active set
[ logger ](path_planning.jl-386): moved 20 to closed set, moved [10] to active set
[ logger ](path_planning.jl-386): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 3 to closed set, moved [5] to active set
[ logger ](path_planning.jl-386): moved 5 to closed set, moved [4] to active set
[ logger ](path_planning.jl-386): moved 4 to closed set, moved [6] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 10, 4, 3, 5, 20, 1])
	active_set:   Set([7, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2    8   15    0    8    5    5    8    8   14   14   15   15    0]
	tF:           [    0    2    0   18   10   18    5    8   15    0    8    5    8    8   14   14   15   15   15    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  5.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    7 => GO(1,6->13)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,6->13)
    cache.tF[v]: 5
    maximum(env.cache.tF): 18

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=18), q_cost = (18.0, 0.0, 6.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=5,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=9,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=10,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=14,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=13,t=21), q_cost = (16.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 6
[ logger ](path_planning.jl-386): moved 7 to closed set, moved [12] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 1])
	active_set:   Set([6, 12])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   12 => COLLECT(1,3,13)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,3,13)
    cache.tF[v]: 21
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 12 to closed set, moved [13] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 12, 1])
	active_set:   Set([13, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   13 => CARRY(1,3,13->1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,3,13->1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=9,t=22), q_cost = (0.0, 1.0, 12.0, 2.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=5,t=23), q_cost = (0.0, 1.0, 12.0, 1.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=1,t=24), q_cost = (0.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 13 to closed set, moved [14] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 13, 12, 1])
	active_set:   Set([14, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   14 => DEPOSIT(1,3,1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,3,1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 14 to closed set, moved [8, 15] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](path_planning.jl-386): moved 8 to closed set, moved [11] to active set
[ logger ](path_planning.jl-386): moved 11 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 12, 1])
	active_set:   Set([15, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   15 => GO(1,1->16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,1->16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=25), q_cost = (0.0, 1.0, 18.0, 5.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=26), q_cost = (0.0, 1.0, 18.0, 4.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=27), q_cost = (0.0, 1.0, 18.0, 3.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=8,t=28), q_cost = (0.0, 1.0, 18.0, 2.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=12,t=29), q_cost = (0.0, 1.0, 18.0, 1.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=16,t=30), q_cost = (0.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](path_planning.jl-386): moved 15 to closed set, moved [16] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([16, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   16 => COLLECT(1,4,16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,4,16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 16 to closed set, moved [17] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([17, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   17 => CARRY(1,4,16->15)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,4,16->15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=15,t=31), q_cost = (0.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-386): moved 17 to closed set, moved [18] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6, 18])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   18 => DEPOSIT(1,4,15)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,4,15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 18 to closed set, moved [9, 19] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](path_planning.jl-386): moved 9 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([19, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   19 => GO(1,15->-1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,15->-1)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 31. Extending terminal node GO(1,15->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-386): moved 19 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6])
	node_queue:   PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 18
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=18), q_cost = (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 18. Extending terminal node GO(2,13->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-386): moved 6 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 31, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](cbs.jl-31): CBS: iter 0 - node Int64[] - Current paths: 
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]

[ logger ](cbs.jl-36): CBS: constraints in node Int64[]: 

[ logger ](cbs.jl-59): CBS: adding constraint to node [1]: StateConstraint: agent_id=1, t=21, (v=9,t=20) -- (e=9 → 13) -- X(v=13,t=21)X
[ logger ](path_planning.jl-386): moved 1 to closed set, moved [2] to active set
[ logger ](path_planning.jl-386): moved 2 to closed set, moved [7] to active set
[ logger ](path_planning.jl-386): moved 20 to closed set, moved [10] to active set
[ logger ](path_planning.jl-386): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 3 to closed set, moved [5] to active set
[ logger ](path_planning.jl-386): moved 5 to closed set, moved [4] to active set
[ logger ](path_planning.jl-386): moved 4 to closed set, moved [6] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 10, 4, 3, 5, 20, 1])
	active_set:   Set([7, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2    8   15    0    8    5    5    8    8   14   14   15   15    0]
	tF:           [    0    2    0   18   10   18    5    8   15    0    8    5    8    8   14   14   15   15   15    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  5.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    7 => GO(1,6->13)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,6->13)
    cache.tF[v]: 5
    maximum(env.cache.tF): 18

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=18), q_cost = (18.0, 0.0, 6.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=5,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=9,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](a_star.jl-32): A*: sequence (v=9,t=20), (e=9 → 13), (v=13,t=21) violates a constraint
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=10,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=14,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](a_star.jl-32): A*: sequence (v=14,t=20), (e=14 → 13), (v=13,t=21) violates a constraint
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=9,t=21), q_cost = (17.0, 0.0, 9.0, 1.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=14,t=21), q_cost = (17.0, 0.0, 9.0, 1.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 8: s = (v=5,t=20), q_cost = (17.0, 0.0, 9.0, 2.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 9: s = (v=10,t=20), q_cost = (17.0, 0.0, 9.0, 2.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 10: s = (v=6,t=19), q_cost = (17.0, 0.0, 9.0, 3.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 11: s = (v=13,t=22), q_cost = (17.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 11
[ logger ](path_planning.jl-386): moved 7 to closed set, moved [12] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 22

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 1])
	active_set:   Set([6, 12])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   12 => COLLECT(1,3,13)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,3,13)
    cache.tF[v]: 22
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=22), q_cost = (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 12 to closed set, moved [13] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 22

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 12, 1])
	active_set:   Set([13, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   13 => CARRY(1,3,13->1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,3,13->1)
    cache.tF[v]: 25
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=22), q_cost = (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=9,t=23), q_cost = (0.0, 1.0, 12.0, 2.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=5,t=24), q_cost = (0.0, 1.0, 12.0, 1.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=1,t=25), q_cost = (0.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 13 to closed set, moved [14] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 25

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 13, 12, 1])
	active_set:   Set([14, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   14 => DEPOSIT(1,3,1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,3,1)
    cache.tF[v]: 25
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=25), q_cost = (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 14 to closed set, moved [8, 15] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 25

[ logger ](path_planning.jl-386): moved 8 to closed set, moved [11] to active set
[ logger ](path_planning.jl-386): moved 11 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 12, 1])
	active_set:   Set([15, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   15 => GO(1,1->16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,1->16)
    cache.tF[v]: 31
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=25), q_cost = (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=26), q_cost = (0.0, 1.0, 18.0, 5.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=27), q_cost = (0.0, 1.0, 18.0, 4.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=28), q_cost = (0.0, 1.0, 18.0, 3.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=8,t=29), q_cost = (0.0, 1.0, 18.0, 2.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=12,t=30), q_cost = (0.0, 1.0, 18.0, 1.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=16,t=31), q_cost = (0.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](path_planning.jl-386): moved 15 to closed set, moved [16] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([16, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   16 => COLLECT(1,4,16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,4,16)
    cache.tF[v]: 31
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=31), q_cost = (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 16 to closed set, moved [17] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([17, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   17 => CARRY(1,4,16->15)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,4,16->15)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=31), q_cost = (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=15,t=32), q_cost = (0.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-386): moved 17 to closed set, moved [18] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6, 18])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   18 => DEPOSIT(1,4,15)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,4,15)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=32), q_cost = (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 18 to closed set, moved [9, 19] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](path_planning.jl-386): moved 9 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([19, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   19 => GO(1,15->-1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,15->-1)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 32
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=32), q_cost = (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 32. Extending terminal node GO(1,15->-1) to 32
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 32. maximum(cache.tF) = 32
[ logger ](path_planning.jl-386): moved 19 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6])
	node_queue:   PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 18
    maximum(env.cache.tF): 32

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 32
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=18), q_cost = (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 18. Extending terminal node GO(2,13->-1) to 32
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 32. maximum(cache.tF) = 32
[ logger ](path_planning.jl-386): moved 6 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 32, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](path_planning.jl-386): moved 1 to closed set, moved [2] to active set
[ logger ](path_planning.jl-386): moved 2 to closed set, moved [7] to active set
[ logger ](path_planning.jl-386): moved 20 to closed set, moved [10] to active set
[ logger ](path_planning.jl-386): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 3 to closed set, moved [5] to active set
[ logger ](path_planning.jl-386): moved 5 to closed set, moved [4] to active set
[ logger ](path_planning.jl-386): moved 4 to closed set, moved [6] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 10, 4, 3, 5, 20, 1])
	active_set:   Set([7, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2    8   15    0    8    5    5    8    8   14   14   15   15    0]
	tF:           [    0    2    0   18   10   18    5    8   15    0    8    5    8    8   14   14   15   15   15    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  5.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    7 => GO(1,6->13)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,6->13)
    cache.tF[v]: 5
    maximum(env.cache.tF): 18

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=18), q_cost = (18.0, 0.0, 6.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=5,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=9,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](a_star.jl-32): A*: sequence (v=9,t=20), (e=9 → 13), (v=13,t=21) violates a constraint
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=10,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=14,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](a_star.jl-32): A*: sequence (v=14,t=20), (e=14 → 13), (v=13,t=21) violates a constraint
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=9,t=21), q_cost = (17.0, 0.0, 9.0, 1.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=14,t=21), q_cost = (17.0, 0.0, 9.0, 1.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 8: s = (v=5,t=20), q_cost = (17.0, 0.0, 9.0, 2.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 9: s = (v=10,t=20), q_cost = (17.0, 0.0, 9.0, 2.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 10: s = (v=6,t=19), q_cost = (17.0, 0.0, 9.0, 3.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 11: s = (v=13,t=22), q_cost = (17.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 11
[ logger ](path_planning.jl-386): moved 7 to closed set, moved [12] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 22

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 1])
	active_set:   Set([6, 12])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   12 => COLLECT(1,3,13)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,3,13)
    cache.tF[v]: 22
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=22), q_cost = (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 12 to closed set, moved [13] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 22

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 12, 1])
	active_set:   Set([13, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   13 => CARRY(1,3,13->1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,3,13->1)
    cache.tF[v]: 25
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=22), q_cost = (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=9,t=23), q_cost = (0.0, 1.0, 12.0, 2.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=5,t=24), q_cost = (0.0, 1.0, 12.0, 1.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=1,t=25), q_cost = (0.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 13 to closed set, moved [14] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 25

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 13, 12, 1])
	active_set:   Set([14, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   14 => DEPOSIT(1,3,1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,3,1)
    cache.tF[v]: 25
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=25), q_cost = (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 14 to closed set, moved [8, 15] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 25

[ logger ](path_planning.jl-386): moved 8 to closed set, moved [11] to active set
[ logger ](path_planning.jl-386): moved 11 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 12, 1])
	active_set:   Set([15, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   15 => GO(1,1->16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,1->16)
    cache.tF[v]: 31
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=25), q_cost = (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=26), q_cost = (0.0, 1.0, 18.0, 5.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=27), q_cost = (0.0, 1.0, 18.0, 4.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=28), q_cost = (0.0, 1.0, 18.0, 3.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=8,t=29), q_cost = (0.0, 1.0, 18.0, 2.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=12,t=30), q_cost = (0.0, 1.0, 18.0, 1.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=16,t=31), q_cost = (0.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](path_planning.jl-386): moved 15 to closed set, moved [16] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([16, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   16 => COLLECT(1,4,16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,4,16)
    cache.tF[v]: 31
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=31), q_cost = (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 16 to closed set, moved [17] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([17, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   17 => CARRY(1,4,16->15)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,4,16->15)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=31), q_cost = (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=15,t=32), q_cost = (0.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-386): moved 17 to closed set, moved [18] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6, 18])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   18 => DEPOSIT(1,4,15)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,4,15)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=32), q_cost = (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 18 to closed set, moved [9, 19] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](path_planning.jl-386): moved 9 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([19, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   19 => GO(1,15->-1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,15->-1)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 32
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=32), q_cost = (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 32. Extending terminal node GO(1,15->-1) to 32
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 32. maximum(cache.tF) = 32
[ logger ](path_planning.jl-386): moved 19 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6])
	node_queue:   PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 18
    maximum(env.cache.tF): 32

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 32
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=18), q_cost = (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 18. Extending terminal node GO(2,13->-1) to 32
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 32. maximum(cache.tF) = 32
[ logger ](path_planning.jl-386): moved 6 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 32, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](cbs.jl-59): CBS: adding constraint to node [2]: StateConstraint: agent_id=2, t=21, (v=13,t=20) -- (e=13 → 13) -- X(v=13,t=21)X
[ logger ](path_planning.jl-386): moved 1 to closed set, moved [2] to active set
[ logger ](path_planning.jl-386): moved 2 to closed set, moved [7] to active set
[ logger ](path_planning.jl-386): moved 20 to closed set, moved [10] to active set
[ logger ](path_planning.jl-386): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 3 to closed set, moved [5] to active set
[ logger ](path_planning.jl-386): moved 5 to closed set, moved [4] to active set
[ logger ](path_planning.jl-386): moved 4 to closed set, moved [6] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 10, 4, 3, 5, 20, 1])
	active_set:   Set([7, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2    8   15    0    8    5    5    8    8   14   14   15   15    0]
	tF:           [    0    2    0   18   10   18    5    8   15    0    8    5    8    8   14   14   15   15   15    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  5.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    7 => GO(1,6->13)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,6->13)
    cache.tF[v]: 5
    maximum(env.cache.tF): 18

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=18), q_cost = (18.0, 0.0, 6.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=5,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=9,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=10,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=14,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=13,t=21), q_cost = (16.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 6
[ logger ](path_planning.jl-386): moved 7 to closed set, moved [12] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 1])
	active_set:   Set([6, 12])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   12 => COLLECT(1,3,13)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,3,13)
    cache.tF[v]: 21
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 12 to closed set, moved [13] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 12, 1])
	active_set:   Set([13, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   13 => CARRY(1,3,13->1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,3,13->1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=9,t=22), q_cost = (0.0, 1.0, 12.0, 2.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=5,t=23), q_cost = (0.0, 1.0, 12.0, 1.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=1,t=24), q_cost = (0.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 13 to closed set, moved [14] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 13, 12, 1])
	active_set:   Set([14, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   14 => DEPOSIT(1,3,1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,3,1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 14 to closed set, moved [8, 15] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](path_planning.jl-386): moved 8 to closed set, moved [11] to active set
[ logger ](path_planning.jl-386): moved 11 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 12, 1])
	active_set:   Set([15, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   15 => GO(1,1->16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,1->16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=25), q_cost = (0.0, 1.0, 18.0, 5.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=26), q_cost = (0.0, 1.0, 18.0, 4.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=27), q_cost = (0.0, 1.0, 18.0, 3.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=8,t=28), q_cost = (0.0, 1.0, 18.0, 2.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=12,t=29), q_cost = (0.0, 1.0, 18.0, 1.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=16,t=30), q_cost = (0.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](path_planning.jl-386): moved 15 to closed set, moved [16] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([16, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   16 => COLLECT(1,4,16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,4,16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 16 to closed set, moved [17] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([17, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   17 => CARRY(1,4,16->15)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,4,16->15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=15,t=31), q_cost = (0.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-386): moved 17 to closed set, moved [18] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6, 18])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   18 => DEPOSIT(1,4,15)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,4,15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 18 to closed set, moved [9, 19] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](path_planning.jl-386): moved 9 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([19, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   19 => GO(1,15->-1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,15->-1)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 31. Extending terminal node GO(1,15->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-386): moved 19 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6])
	node_queue:   PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 18
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=18), q_cost = (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 18. Extending terminal node GO(2,13->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-386): moved 6 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 31, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](path_planning.jl-386): moved 1 to closed set, moved [2] to active set
[ logger ](path_planning.jl-386): moved 2 to closed set, moved [7] to active set
[ logger ](path_planning.jl-386): moved 20 to closed set, moved [10] to active set
[ logger ](path_planning.jl-386): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 3 to closed set, moved [5] to active set
[ logger ](path_planning.jl-386): moved 5 to closed set, moved [4] to active set
[ logger ](path_planning.jl-386): moved 4 to closed set, moved [6] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 10, 4, 3, 5, 20, 1])
	active_set:   Set([7, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2    8   15    0    8    5    5    8    8   14   14   15   15    0]
	tF:           [    0    2    0   18   10   18    5    8   15    0    8    5    8    8   14   14   15   15   15    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  5.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    7 => GO(1,6->13)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,6->13)
    cache.tF[v]: 5
    maximum(env.cache.tF): 18

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=18), q_cost = (18.0, 0.0, 6.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=5,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=9,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=10,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=14,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=13,t=21), q_cost = (16.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 6
[ logger ](path_planning.jl-386): moved 7 to closed set, moved [12] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 1])
	active_set:   Set([6, 12])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   12 => COLLECT(1,3,13)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,3,13)
    cache.tF[v]: 21
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 12 to closed set, moved [13] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 12, 1])
	active_set:   Set([13, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   13 => CARRY(1,3,13->1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,3,13->1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 1.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=9,t=22), q_cost = (0.0, 1.0, 12.0, 2.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=5,t=23), q_cost = (0.0, 1.0, 12.0, 1.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=1,t=24), q_cost = (0.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 13 to closed set, moved [14] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 13, 12, 1])
	active_set:   Set([14, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   14 => DEPOSIT(1,3,1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,3,1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 14 to closed set, moved [8, 15] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](path_planning.jl-386): moved 8 to closed set, moved [11] to active set
[ logger ](path_planning.jl-386): moved 11 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 12, 1])
	active_set:   Set([15, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   15 => GO(1,1->16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,1->16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 1.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=25), q_cost = (0.0, 1.0, 18.0, 5.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=26), q_cost = (0.0, 1.0, 18.0, 4.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=27), q_cost = (0.0, 1.0, 18.0, 3.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=8,t=28), q_cost = (0.0, 1.0, 18.0, 2.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=12,t=29), q_cost = (0.0, 1.0, 18.0, 1.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=16,t=30), q_cost = (0.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](path_planning.jl-386): moved 15 to closed set, moved [16] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([16, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   16 => COLLECT(1,4,16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,4,16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 16 to closed set, moved [17] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([17, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   17 => CARRY(1,4,16->15)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,4,16->15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 1.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=15,t=31), q_cost = (0.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-386): moved 17 to closed set, moved [18] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6, 18])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   18 => DEPOSIT(1,4,15)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,4,15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 18 to closed set, moved [9, 19] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](path_planning.jl-386): moved 9 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([19, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   19 => GO(1,15->-1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,15->-1)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 31. Extending terminal node GO(1,15->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-386): moved 19 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6])
	node_queue:   PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
	tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 18
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=18), q_cost = (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 18. Extending terminal node GO(2,13->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-386): moved 6 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 31
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 31, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](cbs.jl-31): CBS: iter 2 - node [2] - Current paths: 
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]

[ logger ](cbs.jl-36): CBS: constraints in node [2]: 
	StateConstraint: agent_id=2, t=21, (v=-1,t=-1) -- (e=-1 → -1) -- X(v=13,t=21)X

[ logger ](cbs.jl-59): CBS: adding constraint to node [2, 1]: StateConstraint: agent_id=1, t=21, (v=9,t=20) -- (e=9 → 13) -- X(v=13,t=21)X
[ logger ](path_planning.jl-386): moved 1 to closed set, moved [2] to active set
[ logger ](path_planning.jl-386): moved 2 to closed set, moved [7] to active set
[ logger ](path_planning.jl-386): moved 20 to closed set, moved [10] to active set
[ logger ](path_planning.jl-386): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 3 to closed set, moved [5] to active set
[ logger ](path_planning.jl-386): moved 5 to closed set, moved [4] to active set
[ logger ](path_planning.jl-386): moved 4 to closed set, moved [6] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 10, 4, 3, 5, 20, 1])
	active_set:   Set([7, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2    8   15    0    8    5    5    8    8   14   14   15   15    0]
	tF:           [    0    2    0   18   10   18    5    8   15    0    8    5    8    8   14   14   15   15   15    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  5.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    7 => GO(1,6->13)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,6->13)
    cache.tF[v]: 5
    maximum(env.cache.tF): 18

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=18), q_cost = (18.0, 0.0, 6.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=5,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=9,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](a_star.jl-32): A*: sequence (v=9,t=20), (e=9 → 13), (v=13,t=21) violates a constraint
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=10,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=14,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](a_star.jl-32): A*: sequence (v=14,t=20), (e=14 → 13), (v=13,t=21) violates a constraint
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=9,t=21), q_cost = (17.0, 0.0, 9.0, 1.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=14,t=21), q_cost = (17.0, 0.0, 9.0, 1.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 8: s = (v=5,t=20), q_cost = (17.0, 0.0, 9.0, 2.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 9: s = (v=10,t=20), q_cost = (17.0, 0.0, 9.0, 2.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 10: s = (v=6,t=19), q_cost = (17.0, 0.0, 9.0, 3.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 11: s = (v=13,t=22), q_cost = (17.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 11
[ logger ](path_planning.jl-386): moved 7 to closed set, moved [12] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 22

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 1])
	active_set:   Set([6, 12])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   12 => COLLECT(1,3,13)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,3,13)
    cache.tF[v]: 22
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=22), q_cost = (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 12 to closed set, moved [13] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 22

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 12, 1])
	active_set:   Set([13, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   13 => CARRY(1,3,13->1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,3,13->1)
    cache.tF[v]: 25
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=22), q_cost = (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=9,t=23), q_cost = (0.0, 1.0, 12.0, 2.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=5,t=24), q_cost = (0.0, 1.0, 12.0, 1.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=1,t=25), q_cost = (0.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 13 to closed set, moved [14] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 25

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 13, 12, 1])
	active_set:   Set([14, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   14 => DEPOSIT(1,3,1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,3,1)
    cache.tF[v]: 25
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=25), q_cost = (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 14 to closed set, moved [8, 15] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 25

[ logger ](path_planning.jl-386): moved 8 to closed set, moved [11] to active set
[ logger ](path_planning.jl-386): moved 11 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 12, 1])
	active_set:   Set([15, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   15 => GO(1,1->16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,1->16)
    cache.tF[v]: 31
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=25), q_cost = (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=26), q_cost = (0.0, 1.0, 18.0, 5.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=27), q_cost = (0.0, 1.0, 18.0, 4.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=28), q_cost = (0.0, 1.0, 18.0, 3.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=8,t=29), q_cost = (0.0, 1.0, 18.0, 2.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=12,t=30), q_cost = (0.0, 1.0, 18.0, 1.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=16,t=31), q_cost = (0.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](path_planning.jl-386): moved 15 to closed set, moved [16] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([16, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   16 => COLLECT(1,4,16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,4,16)
    cache.tF[v]: 31
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=31), q_cost = (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 16 to closed set, moved [17] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([17, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   17 => CARRY(1,4,16->15)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,4,16->15)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=31), q_cost = (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=15,t=32), q_cost = (0.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-386): moved 17 to closed set, moved [18] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6, 18])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   18 => DEPOSIT(1,4,15)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,4,15)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=32), q_cost = (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 18 to closed set, moved [9, 19] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](path_planning.jl-386): moved 9 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([19, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   19 => GO(1,15->-1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,15->-1)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 32
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=32), q_cost = (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 32. Extending terminal node GO(1,15->-1) to 32
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 32. maximum(cache.tF) = 32
[ logger ](path_planning.jl-386): moved 19 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6])
	node_queue:   PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 18
    maximum(env.cache.tF): 32

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 32
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=18), q_cost = (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 18. Extending terminal node GO(2,13->-1) to 32
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 32. maximum(cache.tF) = 32
[ logger ](path_planning.jl-386): moved 6 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 32, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](path_planning.jl-386): moved 1 to closed set, moved [2] to active set
[ logger ](path_planning.jl-386): moved 2 to closed set, moved [7] to active set
[ logger ](path_planning.jl-386): moved 20 to closed set, moved [10] to active set
[ logger ](path_planning.jl-386): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-386): moved 3 to closed set, moved [5] to active set
[ logger ](path_planning.jl-386): moved 5 to closed set, moved [4] to active set
[ logger ](path_planning.jl-386): moved 4 to closed set, moved [6] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 10, 4, 3, 5, 20, 1])
	active_set:   Set([7, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2    8   15    0    8    5    5    8    8   14   14   15   15    0]
	tF:           [    0    2    0   18   10   18    5    8   15    0    8    5    8    8   14   14   15   15   15    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  5.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    7 => GO(1,6->13)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,6->13)
    cache.tF[v]: 5
    maximum(env.cache.tF): 18

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=18), q_cost = (18.0, 0.0, 6.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=5,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=9,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](a_star.jl-32): A*: sequence (v=9,t=20), (e=9 → 13), (v=13,t=21) violates a constraint
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=10,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=14,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](a_star.jl-32): A*: sequence (v=14,t=20), (e=14 → 13), (v=13,t=21) violates a constraint
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=9,t=21), q_cost = (17.0, 0.0, 9.0, 1.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=14,t=21), q_cost = (17.0, 0.0, 9.0, 1.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 8: s = (v=5,t=20), q_cost = (17.0, 0.0, 9.0, 2.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 9: s = (v=10,t=20), q_cost = (17.0, 0.0, 9.0, 2.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 10: s = (v=6,t=19), q_cost = (17.0, 0.0, 9.0, 3.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 11: s = (v=13,t=22), q_cost = (17.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 11
[ logger ](path_planning.jl-386): moved 7 to closed set, moved [12] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 22

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 1])
	active_set:   Set([6, 12])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   12 => COLLECT(1,3,13)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,3,13)
    cache.tF[v]: 22
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=22), q_cost = (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 12 to closed set, moved [13] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 22

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 12, 1])
	active_set:   Set([13, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   13 => CARRY(1,3,13->1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,3,13->1)
    cache.tF[v]: 25
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=22), q_cost = (22.0, 1.0, 9.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=9,t=23), q_cost = (0.0, 1.0, 12.0, 2.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=5,t=24), q_cost = (0.0, 1.0, 12.0, 1.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=1,t=25), q_cost = (0.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-386): moved 13 to closed set, moved [14] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 25

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 13, 12, 1])
	active_set:   Set([14, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   14 => DEPOSIT(1,3,1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,3,1)
    cache.tF[v]: 25
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=25), q_cost = (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 14 to closed set, moved [8, 15] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 25

[ logger ](path_planning.jl-386): moved 8 to closed set, moved [11] to active set
[ logger ](path_planning.jl-386): moved 11 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 12, 1])
	active_set:   Set([15, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   15 => GO(1,1->16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,1->16)
    cache.tF[v]: 31
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=25), q_cost = (25.0, 1.0, 12.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=26), q_cost = (0.0, 1.0, 18.0, 5.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=27), q_cost = (0.0, 1.0, 18.0, 4.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=28), q_cost = (0.0, 1.0, 18.0, 3.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=8,t=29), q_cost = (0.0, 1.0, 18.0, 2.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=12,t=30), q_cost = (0.0, 1.0, 18.0, 1.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=16,t=31), q_cost = (0.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](path_planning.jl-386): moved 15 to closed set, moved [16] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([16, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   16 => COLLECT(1,4,16)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: COLLECT(1,4,16)
    cache.tF[v]: 31
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=31), q_cost = (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 16 to closed set, moved [17] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([17, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   17 => CARRY(1,4,16->15)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: CARRY(1,4,16->15)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=31), q_cost = (31.0, 1.0, 18.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=15,t=32), q_cost = (0.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-386): moved 17 to closed set, moved [18] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([2, 16, 11, 7, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6, 18])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
	v =   18 => DEPOSIT(1,4,15)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: DEPOSIT(1,4,15)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=32), q_cost = (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-386): moved 18 to closed set, moved [9, 19] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](path_planning.jl-386): moved 9 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([19, 6])
	node_queue:   PriorityQueue(6 => (1, Inf))
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =   19 => GO(1,15->-1)
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(1,15->-1)
    cache.tF[v]: 32
    maximum(env.cache.tF): 32

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 32
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=32), q_cost = (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (32.0, 1.0, 19.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 32. Extending terminal node GO(1,15->-1) to 32
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 32. maximum(cache.tF) = 32
[ logger ](path_planning.jl-386): moved 19 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

[ logger ](pc_tapf_solvers.jl-332): cache: PlanningCache:
	closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
	active_set:   Set([6])
	node_queue:   PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
	           v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20 
	t0:           [    0    0    0   10    0   18    2   25   32    0   25   22   22   25   25   31   31   32   32    0]
	tF:           [    0    2    0   18   10   18   22   25   32    0   25   22   25   25   31   31   32   32   32    0]
	slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 22.0]
	local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 22.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
	v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32   
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-333): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 18
    maximum(env.cache.tF): 32

[ logger ](path_planning.jl-720): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 32
[ logger ](a_star.jl-13): A*: entering...
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=18), q_cost = (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](a_star.jl-21): A*: returning optimal path with cost (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 18. Extending terminal node GO(2,13->-1) to 32
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 32. maximum(cache.tF) = 32
[ logger ](path_planning.jl-386): moved 6 to closed set, moved Int64[] to active set
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) 32
[ logger ](pc_tapf_solvers.jl-341): ISPS:
    routes:
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 32, 22, 25, 32, 0, 25, 22, 25, 25, 31, 31, 32, 32, 32, 0]
    cache.tF[v]: 32

SolverException("Solver time limit exceeded! deadline was Inf, runtime_limit was 100.0")No Solution Found. Returning default solution
SolverException("Solver time limit exceeded! deadline was Inf, runtime_limit was 100.0")[ logger ](replanning.jl-627): Stage 2 - route planner iterations: 4
[ logger ](replanning.jl-620): REPLANNING: Stage 3
