[ logger ](replanning.jl-597): REPLANNING: Stage 1
Academic license - for non-commercial use only
Academic license - for non-commercial use only
[ logger ](task_assignment_solvers.jl-1117): Assignment: Adding edges
    GO(1,1->1) → COLLECT(1,1,1)
    GO(1,4->8) → COLLECT(1,2,8)

[ logger ](path_planning.jl-434): moved 4 to closed set, moved [2] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 2 to closed set, moved [5] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 20 to closed set, moved [9] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 9 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 19 to closed set, moved [10] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 3 to closed set, moved [1] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 1 to closed set, moved [6] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
SearchEnv:
cache: PlanningCache:
    closed_set:   Set([1, 4, 9, 10, 2, 3, 19, 20])
    active_set:   Set([5, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =    5 => GO(1,1->1)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,1->1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,1->1)
    agent_idx:     1
    goal:          (v=1,t=10)

[ logger ](a_star.jl-15): A*: start state: (v=1,t=10)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 5 to closed set, moved [11] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 10

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([1, 4, 9, 10, 2, 3, 19, 5, 20])
    active_set:   Set([11, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   11 => COLLECT(1,1,1)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: COLLECT(1,1,1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: COLLECT(1,1,1)
    agent_idx:     1
    goal:          (v=1,t=10)

[ logger ](a_star.jl-15): A*: start state: (v=1,t=10)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 11 to closed set, moved [12] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 10

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([1, 4, 9, 10, 2, 3, 19, 11, 5, 20])
    active_set:   Set([6, 12])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
    v =   12 => CARRY(1,1,1->4)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: CARRY(1,1,1->4)
    cache.tF[v]: 13
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: CARRY(1,1,1->4)
    agent_idx:     1
    goal:          (v=4,t=13)

[ logger ](a_star.jl-15): A*: start state: (v=1,t=10)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=10) -- (v=1,t=11), h_cost = (2.0, 0.0, 3.0, 3.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=10) -- (v=2,t=11), h_cost = (0.0, 0.0, 3.0, 2.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=10) -- (v=5,t=11), h_cost = (4.0, 0.0, 5.0, 4.0, -11.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=11), q_cost = (0.0, 0.0, 3.0, 2.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=11) -- (v=1,t=12), h_cost = (4.0, 0.0, 5.0, 3.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=11) -- (v=2,t=12), h_cost = (2.0, 0.0, 3.0, 2.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=11) -- (v=3,t=12), h_cost = (0.0, 0.0, 3.0, 1.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=11) -- (v=6,t=12), h_cost = (4.0, 0.0, 5.0, 3.0, -12.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=12), q_cost = (0.0, 0.0, 3.0, 1.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=12) -- (v=2,t=13), h_cost = (4.0, 0.0, 5.0, 2.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=12) -- (v=3,t=13), h_cost = (2.0, 0.0, 3.0, 1.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=12) -- (v=4,t=13), h_cost = (0.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=12) -- (v=7,t=13), h_cost = (4.0, 0.0, 5.0, 2.0, -13.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=13), q_cost = (0.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-434): moved 12 to closed set, moved [13] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 13

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 9, 10, 19, 4, 3, 5, 20, 12, 1])
    active_set:   Set([13, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   13 => DEPOSIT(1,1,4)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: DEPOSIT(1,1,4)
    cache.tF[v]: 13
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: DEPOSIT(1,1,4)
    agent_idx:     1
    goal:          (v=4,t=13)

[ logger ](a_star.jl-15): A*: start state: (v=4,t=13)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=4,t=13), q_cost = (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 13 to closed set, moved [7, 14] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 13

[ logger ](path_planning.jl-434): moved 7 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 12, 1])
    active_set:   Set([14, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   14 => GO(1,4->8)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,4->8)
    cache.tF[v]: 14
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,4->8)
    agent_idx:     1
    goal:          (v=8,t=14)

[ logger ](a_star.jl-15): A*: start state: (v=4,t=13)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=4,t=13), q_cost = (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=13) -- (v=3,t=14), h_cost = (2.0, 0.0, 6.0, 2.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=13) -- (v=4,t=14), h_cost = (1.0, 0.0, 4.0, 1.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=13) -- (v=8,t=14), h_cost = (0.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=8,t=14), q_cost = (0.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-434): moved 14 to closed set, moved [15] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 14

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 12, 1])
    active_set:   Set([15, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   15 => COLLECT(1,2,8)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: COLLECT(1,2,8)
    cache.tF[v]: 14
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: COLLECT(1,2,8)
    agent_idx:     1
    goal:          (v=8,t=14)

[ logger ](a_star.jl-15): A*: start state: (v=8,t=14)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=8,t=14), q_cost = (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 15 to closed set, moved [16] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 14

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([16, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   16 => CARRY(1,2,8->6)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: CARRY(1,2,8->6)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: CARRY(1,2,8->6)
    agent_idx:     1
    goal:          (v=6,t=16)

[ logger ](a_star.jl-15): A*: start state: (v=8,t=14)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=8,t=14), q_cost = (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=14) -- (v=4,t=15), h_cost = (2.0, 0.0, 8.0, 3.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=14) -- (v=7,t=15), h_cost = (0.0, 0.0, 6.0, 1.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=14) -- (v=8,t=15), h_cost = (1.0, 0.0, 6.0, 2.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=14) -- (v=12,t=15), h_cost = (2.0, 0.0, 8.0, 3.0, -15.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=7,t=15), q_cost = (0.0, 0.0, 6.0, 1.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=7,t=15) -- (v=3,t=16), h_cost = (2.0, 0.0, 8.0, 2.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=7,t=15) -- (v=6,t=16), h_cost = (0.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=7,t=15) -- (v=7,t=16), h_cost = (1.0, 0.0, 6.0, 1.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=7,t=15) -- (v=8,t=16), h_cost = (2.0, 0.0, 8.0, 2.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=7,t=15) -- (v=11,t=16), h_cost = (2.0, 0.0, 8.0, 2.0, -16.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=6,t=16), q_cost = (0.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 3
[ logger ](path_planning.jl-434): moved 16 to closed set, moved [17] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 16, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([17, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   17 => DEPOSIT(1,2,6)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: DEPOSIT(1,2,6)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: DEPOSIT(1,2,6)
    agent_idx:     1
    goal:          (v=6,t=16)

[ logger ](a_star.jl-15): A*: start state: (v=6,t=16)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=16), q_cost = (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 17 to closed set, moved [8, 18] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](path_planning.jl-434): moved 8 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([6, 18])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
    v =   18 => GO(1,6->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,6->-1)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](path_planning.jl-723): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 16
[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,6->-1)
    agent_idx:     1
    goal:          (v=-1,t=16)

[ logger ](a_star.jl-15): A*: start state: (v=6,t=16)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=16), q_cost = (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 16. Extending terminal node GO(1,6->-1) to 16
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 16. maximum(cache.tF) = 16
[ logger ](path_planning.jl-434): moved 18 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([6])
    node_queue:   DataStructures.PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](path_planning.jl-723): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 16
[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(2,13->-1)
    agent_idx:     2
    goal:          (v=-1,t=16)

[ logger ](a_star.jl-15): A*: start state: (v=13,t=10)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=10) -- (v=9,t=11), h_cost = (0.0, 0.0, 1.0, 0.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=10) -- (v=13,t=11), h_cost = (0.0, 0.0, 0.0, 0.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=10) -- (v=14,t=11), h_cost = (0.0, 0.0, 1.0, 0.0, -11.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=13,t=11), q_cost = (0.0, 0.0, 0.0, 0.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=11) -- (v=9,t=12), h_cost = (0.0, 0.0, 1.0, 0.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=11) -- (v=13,t=12), h_cost = (0.0, 0.0, 0.0, 0.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=11) -- (v=14,t=12), h_cost = (0.0, 0.0, 1.0, 0.0, -12.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=13,t=12), q_cost = (0.0, 0.0, 0.0, 0.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=12) -- (v=9,t=13), h_cost = (0.0, 0.0, 1.0, 0.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=12) -- (v=13,t=13), h_cost = (0.0, 0.0, 0.0, 0.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=12) -- (v=14,t=13), h_cost = (0.0, 0.0, 1.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=13,t=13), q_cost = (0.0, 0.0, 0.0, 0.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=13) -- (v=9,t=14), h_cost = (0.0, 0.0, 1.0, 0.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=13) -- (v=13,t=14), h_cost = (0.0, 0.0, 0.0, 0.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=13) -- (v=14,t=14), h_cost = (0.0, 0.0, 1.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=13,t=14), q_cost = (0.0, 0.0, 0.0, 0.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=14) -- (v=9,t=15), h_cost = (0.0, 0.0, 1.0, 0.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=14) -- (v=13,t=15), h_cost = (0.0, 0.0, 0.0, 0.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=14) -- (v=14,t=15), h_cost = (0.0, 0.0, 1.0, 0.0, -15.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=13,t=15), q_cost = (0.0, 0.0, 0.0, 0.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=15) -- (v=9,t=16), h_cost = (0.0, 0.0, 1.0, 0.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=15) -- (v=13,t=16), h_cost = (0.0, 0.0, 0.0, 0.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=15) -- (v=14,t=16), h_cost = (0.0, 0.0, 1.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=13,t=16), q_cost = (0.0, 0.0, 0.0, 0.0, -16.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (16.0, 0.0, 0.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 16. Extending terminal node GO(2,13->-1) to 16
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 16. maximum(cache.tF) = 16
[ logger ](path_planning.jl-434): moved 6 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 16, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 16, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](path_planning.jl-434): moved 4 to closed set, moved [2] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 2 to closed set, moved [5] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 20 to closed set, moved [9] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 9 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 19 to closed set, moved [10] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 3 to closed set, moved [1] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](path_planning.jl-434): moved 1 to closed set, moved [6] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 9, 10, 19, 4, 3, 20, 1])
    active_set:   Set([5, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =    5 => GO(1,1->1)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,1->1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,1->1)
    agent_idx:     1
    goal:          (v=1,t=10)

[ logger ](a_star.jl-15): A*: start state: (v=1,t=10)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 5 to closed set, moved [11] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 10

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 9, 10, 19, 4, 3, 5, 20, 1])
    active_set:   Set([11, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   11 => COLLECT(1,1,1)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: COLLECT(1,1,1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: COLLECT(1,1,1)
    agent_idx:     1
    goal:          (v=1,t=10)

[ logger ](a_star.jl-15): A*: start state: (v=1,t=10)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 11 to closed set, moved [12] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 10

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 9, 10, 19, 4, 3, 5, 20, 1])
    active_set:   Set([6, 12])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
    v =   12 => CARRY(1,1,1->4)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10
   1: [1   1   1   1   1   1   1   1   1   1   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: CARRY(1,1,1->4)
    cache.tF[v]: 13
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: CARRY(1,1,1->4)
    agent_idx:     1
    goal:          (v=4,t=13)

[ logger ](a_star.jl-15): A*: start state: (v=1,t=10)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=10) -- (v=1,t=11), h_cost = (2.0, 0.0, 3.0, 3.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=10) -- (v=2,t=11), h_cost = (0.0, 0.0, 3.0, 2.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=10) -- (v=5,t=11), h_cost = (4.0, 0.0, 5.0, 4.0, -11.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=11), q_cost = (0.0, 0.0, 3.0, 2.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=11) -- (v=1,t=12), h_cost = (4.0, 0.0, 5.0, 3.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=11) -- (v=2,t=12), h_cost = (2.0, 0.0, 3.0, 2.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=11) -- (v=3,t=12), h_cost = (0.0, 0.0, 3.0, 1.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=11) -- (v=6,t=12), h_cost = (4.0, 0.0, 5.0, 3.0, -12.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=12), q_cost = (0.0, 0.0, 3.0, 1.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=12) -- (v=2,t=13), h_cost = (4.0, 0.0, 5.0, 2.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=12) -- (v=3,t=13), h_cost = (2.0, 0.0, 3.0, 1.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=12) -- (v=4,t=13), h_cost = (0.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=12) -- (v=7,t=13), h_cost = (4.0, 0.0, 5.0, 2.0, -13.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=13), q_cost = (0.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-434): moved 12 to closed set, moved [13] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 13

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 9, 10, 19, 4, 3, 5, 20, 12, 1])
    active_set:   Set([13, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   13 => DEPOSIT(1,1,4)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: DEPOSIT(1,1,4)
    cache.tF[v]: 13
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: DEPOSIT(1,1,4)
    agent_idx:     1
    goal:          (v=4,t=13)

[ logger ](a_star.jl-15): A*: start state: (v=4,t=13)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=4,t=13), q_cost = (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 13 to closed set, moved [7, 14] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 13

[ logger ](path_planning.jl-434): moved 7 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 12, 1])
    active_set:   Set([14, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   14 => GO(1,4->8)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,4->8)
    cache.tF[v]: 14
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,4->8)
    agent_idx:     1
    goal:          (v=8,t=14)

[ logger ](a_star.jl-15): A*: start state: (v=4,t=13)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=4,t=13), q_cost = (13.0, 0.0, 3.0, 0.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=13) -- (v=3,t=14), h_cost = (2.0, 0.0, 6.0, 2.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=13) -- (v=4,t=14), h_cost = (1.0, 0.0, 4.0, 1.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=13) -- (v=8,t=14), h_cost = (0.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=8,t=14), q_cost = (0.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-434): moved 14 to closed set, moved [15] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 14

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 12, 1])
    active_set:   Set([15, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   15 => COLLECT(1,2,8)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: COLLECT(1,2,8)
    cache.tF[v]: 14
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: COLLECT(1,2,8)
    agent_idx:     1
    goal:          (v=8,t=14)

[ logger ](a_star.jl-15): A*: start state: (v=8,t=14)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=8,t=14), q_cost = (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 15 to closed set, moved [16] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 14

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([16, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   16 => CARRY(1,2,8->6)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: CARRY(1,2,8->6)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: CARRY(1,2,8->6)
    agent_idx:     1
    goal:          (v=6,t=16)

[ logger ](a_star.jl-15): A*: start state: (v=8,t=14)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=8,t=14), q_cost = (14.0, 0.0, 4.0, 0.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=14) -- (v=4,t=15), h_cost = (2.0, 0.0, 8.0, 3.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=14) -- (v=7,t=15), h_cost = (0.0, 0.0, 6.0, 1.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=14) -- (v=8,t=15), h_cost = (1.0, 0.0, 6.0, 2.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=14) -- (v=12,t=15), h_cost = (2.0, 0.0, 8.0, 3.0, -15.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=7,t=15), q_cost = (0.0, 0.0, 6.0, 1.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=7,t=15) -- (v=3,t=16), h_cost = (2.0, 0.0, 8.0, 2.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=7,t=15) -- (v=6,t=16), h_cost = (0.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=7,t=15) -- (v=7,t=16), h_cost = (1.0, 0.0, 6.0, 1.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=7,t=15) -- (v=8,t=16), h_cost = (2.0, 0.0, 8.0, 2.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=7,t=15) -- (v=11,t=16), h_cost = (2.0, 0.0, 8.0, 2.0, -16.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=6,t=16), q_cost = (0.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 3
[ logger ](path_planning.jl-434): moved 16 to closed set, moved [17] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 16, 11, 7, 9, 10, 19, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([17, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   17 => DEPOSIT(1,2,6)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: DEPOSIT(1,2,6)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: DEPOSIT(1,2,6)
    agent_idx:     1
    goal:          (v=6,t=16)

[ logger ](a_star.jl-15): A*: start state: (v=6,t=16)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=16), q_cost = (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 17 to closed set, moved [8, 18] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](path_planning.jl-434): moved 8 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([6, 18])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
    v =   18 => GO(1,6->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,6->-1)
    cache.tF[v]: 16
    maximum(env.cache.tF): 16

[ logger ](path_planning.jl-723): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 16
[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,6->-1)
    agent_idx:     1
    goal:          (v=-1,t=16)

[ logger ](a_star.jl-15): A*: start state: (v=6,t=16)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=16), q_cost = (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (16.0, 0.0, 6.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 16. Extending terminal node GO(1,6->-1) to 16
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 16. maximum(cache.tF) = 16
[ logger ](path_planning.jl-434): moved 18 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 10, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([6])
    node_queue:   DataStructures.PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0    0   10   10   13   16    0    0   10   10   13   13   14   14   16   16    0    0]
    tF:           [   10   10    0    0   10   10   13   16    0    0   10   13   13   14   14   16   16   16    0    0]
    slack:        [  Inf  0.0  Inf  0.0  0.0  Inf  0.0  Inf 10.0  Inf  0.0  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf 10.0]
                  [  Inf  0.0  Inf  0.0  0.0  Inf  Inf  0.0 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 14.0 10.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  0.0  Inf  Inf  Inf 10.0 14.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 10
    maximum(env.cache.tF): 16

[ logger ](path_planning.jl-723): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 16
[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(2,13->-1)
    agent_idx:     2
    goal:          (v=-1,t=16)

[ logger ](a_star.jl-15): A*: start state: (v=13,t=10)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=10), q_cost = (10.0, 0.0, 0.0, 0.0, -10.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=10) -- (v=9,t=11), h_cost = (0.0, 0.0, 1.0, 0.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=10) -- (v=13,t=11), h_cost = (0.0, 0.0, 0.0, 0.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=10) -- (v=14,t=11), h_cost = (0.0, 0.0, 1.0, 0.0, -11.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=13,t=11), q_cost = (0.0, 0.0, 0.0, 0.0, -11.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=11) -- (v=9,t=12), h_cost = (0.0, 0.0, 1.0, 0.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=11) -- (v=13,t=12), h_cost = (0.0, 0.0, 0.0, 0.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=11) -- (v=14,t=12), h_cost = (0.0, 0.0, 1.0, 0.0, -12.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=13,t=12), q_cost = (0.0, 0.0, 0.0, 0.0, -12.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=12) -- (v=9,t=13), h_cost = (0.0, 0.0, 1.0, 0.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=12) -- (v=13,t=13), h_cost = (0.0, 0.0, 0.0, 0.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=12) -- (v=14,t=13), h_cost = (0.0, 0.0, 1.0, 0.0, -13.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=13,t=13), q_cost = (0.0, 0.0, 0.0, 0.0, -13.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=13) -- (v=9,t=14), h_cost = (0.0, 0.0, 1.0, 0.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=13) -- (v=13,t=14), h_cost = (0.0, 0.0, 0.0, 0.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=13) -- (v=14,t=14), h_cost = (0.0, 0.0, 1.0, 0.0, -14.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=13,t=14), q_cost = (0.0, 0.0, 0.0, 0.0, -14.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=14) -- (v=9,t=15), h_cost = (0.0, 0.0, 1.0, 0.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=14) -- (v=13,t=15), h_cost = (0.0, 0.0, 0.0, 0.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=14) -- (v=14,t=15), h_cost = (0.0, 0.0, 1.0, 0.0, -15.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=13,t=15), q_cost = (0.0, 0.0, 0.0, 0.0, -15.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=15) -- (v=9,t=16), h_cost = (0.0, 0.0, 1.0, 0.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=15) -- (v=13,t=16), h_cost = (0.0, 0.0, 0.0, 0.0, -16.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=15) -- (v=14,t=16), h_cost = (0.0, 0.0, 1.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=13,t=16), q_cost = (0.0, 0.0, 0.0, 0.0, -16.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (16.0, 0.0, 0.0, 0.0, -16.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 16. Extending terminal node GO(2,13->-1) to 16
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 16. maximum(cache.tF) = 16
[ logger ](path_planning.jl-434): moved 6 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [10, 10, 0, 0, 10, 16, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 16
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [10, 10, 0, 0, 10, 16, 13, 16, 0, 0, 10, 13, 13, 14, 14, 16, 16, 16, 0, 0]
    cache.tF[v]: 16

[ logger ](cbs.jl-31): CBS: iter 0 - node Int64[] - Current paths:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]

[ logger ](cbs.jl-36): CBS: constraints in node Int64[]:

[ logger ](cbs.jl-50): Optimal solution found by CBS! Cost = (29.0, 0.0, 6.0, 0.0, -32.0)
[ logger ](pc_tapf_solvers.jl-556): NBS: Reached 1-iteration limit.
[ logger ](replanning.jl-604): Stage 1 - route planner iterations: 0
[ logger ](replanning.jl-597): REPLANNING: Stage 2
Academic license - for non-commercial use only
Academic license - for non-commercial use only
[ logger ](task_assignment_solvers.jl-1117): Assignment: Adding edges
    GO(1,6->13) → COLLECT(1,3,13)
    GO(1,1->16) → COLLECT(1,4,16)

[ logger ](path_planning.jl-434): moved 1 to closed set, moved [2] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 2 to closed set, moved [7] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 20 to closed set, moved [10] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 3 to closed set, moved [5] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 5 to closed set, moved [4] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 4 to closed set, moved [6] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([20, 4, 10, 2, 3, 5, 1])
    active_set:   Set([7, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2    8   15    0    8    5    5    8    8   14   14   15   15    0]
    tF:           [    0    2    0   18   10   18    5    8   15    0    8    5    8    8   14   14   15   15   15    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  5.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =    7 => GO(1,6->13)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,6->13)
    cache.tF[v]: 5
    maximum(env.cache.tF): 18

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,6->13)
    agent_idx:     1
    goal:          (v=13,t=5)

[ logger ](a_star.jl-15): A*: start state: (v=6,t=18)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=18), q_cost = (18.0, 0.0, 6.0, 0.0, -18.0)
[ logger ](a_star.jl-31): A*: exploring (v=6,t=18) -- (v=2,t=19), h_cost = (18.0, 0.0, 11.0, 4.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=6,t=18) -- (v=5,t=19), h_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=6,t=18) -- (v=6,t=19), h_cost = (17.0, 0.0, 9.0, 3.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=6,t=18) -- (v=7,t=19), h_cost = (18.0, 0.0, 11.0, 4.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=6,t=18) -- (v=10,t=19), h_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=5,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=19) -- (v=1,t=20), h_cost = (18.0, 0.0, 11.0, 3.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=19) -- (v=5,t=20), h_cost = (17.0, 0.0, 9.0, 2.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=19) -- (v=6,t=20), h_cost = (18.0, 0.0, 11.0, 3.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=19) -- (v=9,t=20), h_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=9,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=20) -- (v=5,t=21), h_cost = (18.0, 0.0, 11.0, 2.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=20) -- (v=9,t=21), h_cost = (17.0, 0.0, 9.0, 1.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=20) -- (v=10,t=21), h_cost = (18.0, 0.0, 11.0, 2.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=20) -- (v=13,t=21), h_cost = (16.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=13,t=21), q_cost = (16.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-434): moved 7 to closed set, moved [12] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([20, 4, 7, 10, 2, 3, 5, 1])
    active_set:   Set([6, 12])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
    v =   12 => COLLECT(1,3,13)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: COLLECT(1,3,13)
    cache.tF[v]: 21
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: COLLECT(1,3,13)
    agent_idx:     1
    goal:          (v=13,t=21)

[ logger ](a_star.jl-15): A*: start state: (v=13,t=21)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 12 to closed set, moved [13] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([20, 4, 7, 10, 2, 3, 5, 12, 1])
    active_set:   Set([13, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   13 => CARRY(1,3,13->1)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: CARRY(1,3,13->1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: CARRY(1,3,13->1)
    agent_idx:     1
    goal:          (v=1,t=24)

[ logger ](a_star.jl-15): A*: start state: (v=13,t=21)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=21) -- (v=9,t=22), h_cost = (0.0, 0.0, 12.0, 2.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=21) -- (v=13,t=22), h_cost = (1.0, 0.0, 12.0, 3.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=21) -- (v=14,t=22), h_cost = (2.0, 0.0, 14.0, 4.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=9,t=22), q_cost = (0.0, 0.0, 12.0, 2.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=22) -- (v=5,t=23), h_cost = (0.0, 0.0, 12.0, 1.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=22) -- (v=9,t=23), h_cost = (1.0, 0.0, 12.0, 2.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=22) -- (v=10,t=23), h_cost = (2.0, 0.0, 14.0, 3.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=22) -- (v=13,t=23), h_cost = (2.0, 0.0, 14.0, 3.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=5,t=23), q_cost = (0.0, 0.0, 12.0, 1.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=23) -- (v=1,t=24), h_cost = (0.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=23) -- (v=5,t=24), h_cost = (1.0, 0.0, 12.0, 1.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=23) -- (v=6,t=24), h_cost = (2.0, 0.0, 14.0, 2.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=23) -- (v=9,t=24), h_cost = (2.0, 0.0, 14.0, 2.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=1,t=24), q_cost = (0.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-434): moved 13 to closed set, moved [14] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([20, 4, 7, 10, 13, 2, 3, 5, 12, 1])
    active_set:   Set([14, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   14 => DEPOSIT(1,3,1)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: DEPOSIT(1,3,1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: DEPOSIT(1,3,1)
    agent_idx:     1
    goal:          (v=1,t=24)

[ logger ](a_star.jl-15): A*: start state: (v=1,t=24)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 14 to closed set, moved [8, 15] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](path_planning.jl-434): moved 8 to closed set, moved [11] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](path_planning.jl-434): moved 11 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 12, 1])
    active_set:   Set([15, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   15 => GO(1,1->16)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,1->16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,1->16)
    agent_idx:     1
    goal:          (v=16,t=30)

[ logger ](a_star.jl-15): A*: start state: (v=1,t=24)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=24) -- (v=1,t=25), h_cost = (1.0, 0.0, 18.0, 6.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=24) -- (v=2,t=25), h_cost = (0.0, 0.0, 18.0, 5.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=24) -- (v=5,t=25), h_cost = (0.0, 0.0, 18.0, 5.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=25), q_cost = (0.0, 0.0, 18.0, 5.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=25) -- (v=1,t=26), h_cost = (2.0, 0.0, 20.0, 6.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=25) -- (v=2,t=26), h_cost = (1.0, 0.0, 18.0, 5.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=25) -- (v=3,t=26), h_cost = (0.0, 0.0, 18.0, 4.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=25) -- (v=6,t=26), h_cost = (0.0, 0.0, 18.0, 4.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=26), q_cost = (0.0, 0.0, 18.0, 4.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=26) -- (v=2,t=27), h_cost = (2.0, 0.0, 20.0, 5.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=26) -- (v=3,t=27), h_cost = (1.0, 0.0, 18.0, 4.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=26) -- (v=4,t=27), h_cost = (0.0, 0.0, 18.0, 3.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=26) -- (v=7,t=27), h_cost = (0.0, 0.0, 18.0, 3.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=27), q_cost = (0.0, 0.0, 18.0, 3.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=27) -- (v=3,t=28), h_cost = (2.0, 0.0, 20.0, 4.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=27) -- (v=4,t=28), h_cost = (1.0, 0.0, 18.0, 3.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=27) -- (v=8,t=28), h_cost = (0.0, 0.0, 18.0, 2.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=8,t=28), q_cost = (0.0, 0.0, 18.0, 2.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=28) -- (v=4,t=29), h_cost = (2.0, 0.0, 20.0, 3.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=28) -- (v=7,t=29), h_cost = (2.0, 0.0, 20.0, 3.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=28) -- (v=8,t=29), h_cost = (1.0, 0.0, 18.0, 2.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=28) -- (v=12,t=29), h_cost = (0.0, 0.0, 18.0, 1.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=12,t=29), q_cost = (0.0, 0.0, 18.0, 1.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=12,t=29) -- (v=8,t=30), h_cost = (2.0, 0.0, 20.0, 2.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=12,t=29) -- (v=11,t=30), h_cost = (2.0, 0.0, 20.0, 2.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=12,t=29) -- (v=12,t=30), h_cost = (1.0, 0.0, 18.0, 1.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=12,t=29) -- (v=16,t=30), h_cost = (0.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=16,t=30), q_cost = (0.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](path_planning.jl-434): moved 15 to closed set, moved [16] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([16, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   16 => COLLECT(1,4,16)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: COLLECT(1,4,16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: COLLECT(1,4,16)
    agent_idx:     1
    goal:          (v=16,t=30)

[ logger ](a_star.jl-15): A*: start state: (v=16,t=30)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 16 to closed set, moved [17] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 16, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([17, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   17 => CARRY(1,4,16->15)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: CARRY(1,4,16->15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: CARRY(1,4,16->15)
    agent_idx:     1
    goal:          (v=15,t=31)

[ logger ](a_star.jl-15): A*: start state: (v=16,t=30)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=16,t=30) -- (v=12,t=31), h_cost = (2.0, 0.0, 21.0, 2.0, -31.0)
[ logger ](a_star.jl-31): A*: exploring (v=16,t=30) -- (v=15,t=31), h_cost = (0.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-31): A*: exploring (v=16,t=30) -- (v=16,t=31), h_cost = (1.0, 0.0, 19.0, 1.0, -31.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=15,t=31), q_cost = (0.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-434): moved 17 to closed set, moved [18] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 16, 11, 7, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([6, 18])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
    v =   18 => DEPOSIT(1,4,15)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: DEPOSIT(1,4,15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: DEPOSIT(1,4,15)
    agent_idx:     1
    goal:          (v=15,t=31)

[ logger ](a_star.jl-15): A*: start state: (v=15,t=31)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 18 to closed set, moved [9, 19] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](path_planning.jl-434): moved 9 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([19, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   19 => GO(1,15->-1)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,15->-1)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-723): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,15->-1)
    agent_idx:     1
    goal:          (v=-1,t=31)

[ logger ](a_star.jl-15): A*: start state: (v=15,t=31)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 31. Extending terminal node GO(1,15->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-434): moved 19 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([6])
    node_queue:   DataStructures.PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 18
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-723): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(2,13->-1)
    agent_idx:     2
    goal:          (v=-1,t=31)

[ logger ](a_star.jl-15): A*: start state: (v=13,t=18)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=18), q_cost = (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=18) -- (v=9,t=19), h_cost = (0.0, 0.0, 1.0, 0.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=18) -- (v=13,t=19), h_cost = (0.0, 0.0, 0.0, 0.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=18) -- (v=14,t=19), h_cost = (0.0, 0.0, 1.0, 0.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=13,t=19), q_cost = (0.0, 0.0, 0.0, 0.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=19) -- (v=9,t=20), h_cost = (0.0, 1.0, 1.0, 0.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=19) -- (v=13,t=20), h_cost = (0.0, 0.0, 0.0, 0.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=19) -- (v=14,t=20), h_cost = (0.0, 0.0, 1.0, 0.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=13,t=20), q_cost = (0.0, 0.0, 0.0, 0.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=20) -- (v=9,t=21), h_cost = (0.0, 1.0, 1.0, 0.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=20) -- (v=13,t=21), h_cost = (0.0, 1.0, 0.0, 0.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=20) -- (v=14,t=21), h_cost = (0.0, 0.0, 1.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=14,t=21), q_cost = (0.0, 0.0, 1.0, 0.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=21) -- (v=10,t=22), h_cost = (0.0, 0.0, 2.0, 0.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=21) -- (v=13,t=22), h_cost = (0.0, 0.0, 2.0, 0.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=21) -- (v=14,t=22), h_cost = (0.0, 0.0, 1.0, 0.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=21) -- (v=15,t=22), h_cost = (0.0, 0.0, 2.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=14,t=22), q_cost = (0.0, 0.0, 1.0, 0.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=22) -- (v=10,t=23), h_cost = (0.0, 0.0, 2.0, 0.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=22) -- (v=13,t=23), h_cost = (0.0, 0.0, 2.0, 0.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=22) -- (v=14,t=23), h_cost = (0.0, 0.0, 1.0, 0.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=22) -- (v=15,t=23), h_cost = (0.0, 0.0, 2.0, 0.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=14,t=23), q_cost = (0.0, 0.0, 1.0, 0.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=23) -- (v=10,t=24), h_cost = (0.0, 0.0, 2.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=23) -- (v=13,t=24), h_cost = (0.0, 0.0, 2.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=23) -- (v=14,t=24), h_cost = (0.0, 0.0, 1.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=23) -- (v=15,t=24), h_cost = (0.0, 0.0, 2.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=14,t=24), q_cost = (0.0, 0.0, 1.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=24) -- (v=10,t=25), h_cost = (0.0, 0.0, 2.0, 0.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=24) -- (v=13,t=25), h_cost = (0.0, 0.0, 2.0, 0.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=24) -- (v=14,t=25), h_cost = (0.0, 0.0, 1.0, 0.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=24) -- (v=15,t=25), h_cost = (0.0, 0.0, 2.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 8: s = (v=14,t=25), q_cost = (0.0, 0.0, 1.0, 0.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=25) -- (v=10,t=26), h_cost = (0.0, 0.0, 2.0, 0.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=25) -- (v=13,t=26), h_cost = (0.0, 0.0, 2.0, 0.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=25) -- (v=14,t=26), h_cost = (0.0, 0.0, 1.0, 0.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=25) -- (v=15,t=26), h_cost = (0.0, 0.0, 2.0, 0.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 9: s = (v=14,t=26), q_cost = (0.0, 0.0, 1.0, 0.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=26) -- (v=10,t=27), h_cost = (0.0, 0.0, 2.0, 0.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=26) -- (v=13,t=27), h_cost = (0.0, 0.0, 2.0, 0.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=26) -- (v=14,t=27), h_cost = (0.0, 0.0, 1.0, 0.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=26) -- (v=15,t=27), h_cost = (0.0, 0.0, 2.0, 0.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 10: s = (v=14,t=27), q_cost = (0.0, 0.0, 1.0, 0.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=27) -- (v=10,t=28), h_cost = (0.0, 0.0, 2.0, 0.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=27) -- (v=13,t=28), h_cost = (0.0, 0.0, 2.0, 0.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=27) -- (v=14,t=28), h_cost = (0.0, 0.0, 1.0, 0.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=27) -- (v=15,t=28), h_cost = (0.0, 0.0, 2.0, 0.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 11: s = (v=14,t=28), q_cost = (0.0, 0.0, 1.0, 0.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=28) -- (v=10,t=29), h_cost = (0.0, 0.0, 2.0, 0.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=28) -- (v=13,t=29), h_cost = (0.0, 0.0, 2.0, 0.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=28) -- (v=14,t=29), h_cost = (0.0, 0.0, 1.0, 0.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=28) -- (v=15,t=29), h_cost = (0.0, 0.0, 2.0, 0.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 12: s = (v=14,t=29), q_cost = (0.0, 0.0, 1.0, 0.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=29) -- (v=10,t=30), h_cost = (0.0, 0.0, 2.0, 0.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=29) -- (v=13,t=30), h_cost = (0.0, 0.0, 2.0, 0.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=29) -- (v=14,t=30), h_cost = (0.0, 0.0, 1.0, 0.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=29) -- (v=15,t=30), h_cost = (0.0, 0.0, 2.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 13: s = (v=14,t=30), q_cost = (0.0, 0.0, 1.0, 0.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=30) -- (v=10,t=31), h_cost = (0.0, 0.0, 2.0, 0.0, -31.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=30) -- (v=13,t=31), h_cost = (0.0, 0.0, 2.0, 0.0, -31.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=30) -- (v=14,t=31), h_cost = (0.0, 0.0, 1.0, 0.0, -31.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=30) -- (v=15,t=31), h_cost = (0.0, 1.0, 2.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 14: s = (v=14,t=31), q_cost = (0.0, 0.0, 1.0, 0.0, -31.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (31.0, 0.0, 1.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 14
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 31. Extending terminal node GO(2,13->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-434): moved 6 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 31, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  14  14  14  14  14  14  14  14  14  14  14  ]
    cache.tF: [0, 2, 0, 18, 10, 31, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](path_planning.jl-434): moved 1 to closed set, moved [2] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 2 to closed set, moved [7] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 20 to closed set, moved [10] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 10 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 3 to closed set, moved [5] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 5 to closed set, moved [4] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](path_planning.jl-434): moved 4 to closed set, moved [6] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 5, 8, 15, 0, 8, 5, 8, 8, 14, 14, 15, 15, 15, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 10, 4, 3, 5, 20, 1])
    active_set:   Set([7, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2    8   15    0    8    5    5    8    8   14   14   15   15    0]
    tF:           [    0    2    0   18   10   18    5    8   15    0    8    5    8    8   14   14   15   15   15    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  5.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf  5.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =    7 => GO(1,6->13)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,6->13)
    cache.tF[v]: 5
    maximum(env.cache.tF): 18

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,6->13)
    agent_idx:     1
    goal:          (v=13,t=5)

[ logger ](a_star.jl-15): A*: start state: (v=6,t=18)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=6,t=18), q_cost = (18.0, 0.0, 6.0, 0.0, -18.0)
[ logger ](a_star.jl-31): A*: exploring (v=6,t=18) -- (v=2,t=19), h_cost = (18.0, 0.0, 11.0, 4.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=6,t=18) -- (v=5,t=19), h_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=6,t=18) -- (v=6,t=19), h_cost = (17.0, 0.0, 9.0, 3.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=6,t=18) -- (v=7,t=19), h_cost = (18.0, 0.0, 11.0, 4.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=6,t=18) -- (v=10,t=19), h_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=5,t=19), q_cost = (16.0, 0.0, 9.0, 2.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=19) -- (v=1,t=20), h_cost = (18.0, 0.0, 11.0, 3.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=19) -- (v=5,t=20), h_cost = (17.0, 0.0, 9.0, 2.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=19) -- (v=6,t=20), h_cost = (18.0, 0.0, 11.0, 3.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=19) -- (v=9,t=20), h_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=9,t=20), q_cost = (16.0, 0.0, 9.0, 1.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=20) -- (v=5,t=21), h_cost = (18.0, 0.0, 11.0, 2.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=20) -- (v=9,t=21), h_cost = (17.0, 0.0, 9.0, 1.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=20) -- (v=10,t=21), h_cost = (18.0, 0.0, 11.0, 2.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=20) -- (v=13,t=21), h_cost = (16.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=13,t=21), q_cost = (16.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-434): moved 7 to closed set, moved [12] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 1])
    active_set:   Set([6, 12])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
    v =   12 => COLLECT(1,3,13)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: COLLECT(1,3,13)
    cache.tF[v]: 21
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: COLLECT(1,3,13)
    agent_idx:     1
    goal:          (v=13,t=21)

[ logger ](a_star.jl-15): A*: start state: (v=13,t=21)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 12 to closed set, moved [13] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 21

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 12, 1])
    active_set:   Set([13, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   13 => CARRY(1,3,13->1)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: CARRY(1,3,13->1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: CARRY(1,3,13->1)
    agent_idx:     1
    goal:          (v=1,t=24)

[ logger ](a_star.jl-15): A*: start state: (v=13,t=21)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=21), q_cost = (21.0, 0.0, 9.0, 0.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=21) -- (v=9,t=22), h_cost = (0.0, 0.0, 12.0, 2.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=21) -- (v=13,t=22), h_cost = (1.0, 0.0, 12.0, 3.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=21) -- (v=14,t=22), h_cost = (2.0, 1.0, 14.0, 4.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=9,t=22), q_cost = (0.0, 0.0, 12.0, 2.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=22) -- (v=5,t=23), h_cost = (0.0, 0.0, 12.0, 1.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=22) -- (v=9,t=23), h_cost = (1.0, 0.0, 12.0, 2.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=22) -- (v=10,t=23), h_cost = (2.0, 0.0, 14.0, 3.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=9,t=22) -- (v=13,t=23), h_cost = (2.0, 0.0, 14.0, 3.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=5,t=23), q_cost = (0.0, 0.0, 12.0, 1.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=23) -- (v=1,t=24), h_cost = (0.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=23) -- (v=5,t=24), h_cost = (1.0, 0.0, 12.0, 1.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=23) -- (v=6,t=24), h_cost = (2.0, 0.0, 14.0, 2.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=5,t=23) -- (v=9,t=24), h_cost = (2.0, 0.0, 14.0, 2.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=1,t=24), q_cost = (0.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 4
[ logger ](path_planning.jl-434): moved 13 to closed set, moved [14] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 7, 10, 4, 3, 5, 20, 13, 12, 1])
    active_set:   Set([14, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   14 => DEPOSIT(1,3,1)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: DEPOSIT(1,3,1)
    cache.tF[v]: 24
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: DEPOSIT(1,3,1)
    agent_idx:     1
    goal:          (v=1,t=24)

[ logger ](a_star.jl-15): A*: start state: (v=1,t=24)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 14 to closed set, moved [8, 15] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 24

[ logger ](path_planning.jl-434): moved 8 to closed set, moved [11] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](path_planning.jl-434): moved 11 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 12, 1])
    active_set:   Set([15, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   15 => GO(1,1->16)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,1->16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,1->16)
    agent_idx:     1
    goal:          (v=16,t=30)

[ logger ](a_star.jl-15): A*: start state: (v=1,t=24)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=1,t=24), q_cost = (24.0, 0.0, 12.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=24) -- (v=1,t=25), h_cost = (1.0, 0.0, 18.0, 6.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=24) -- (v=2,t=25), h_cost = (0.0, 0.0, 18.0, 5.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=1,t=24) -- (v=5,t=25), h_cost = (0.0, 0.0, 18.0, 5.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=2,t=25), q_cost = (0.0, 0.0, 18.0, 5.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=25) -- (v=1,t=26), h_cost = (2.0, 0.0, 20.0, 6.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=25) -- (v=2,t=26), h_cost = (1.0, 0.0, 18.0, 5.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=25) -- (v=3,t=26), h_cost = (0.0, 0.0, 18.0, 4.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=2,t=25) -- (v=6,t=26), h_cost = (0.0, 0.0, 18.0, 4.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=3,t=26), q_cost = (0.0, 0.0, 18.0, 4.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=26) -- (v=2,t=27), h_cost = (2.0, 0.0, 20.0, 5.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=26) -- (v=3,t=27), h_cost = (1.0, 0.0, 18.0, 4.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=26) -- (v=4,t=27), h_cost = (0.0, 0.0, 18.0, 3.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=3,t=26) -- (v=7,t=27), h_cost = (0.0, 0.0, 18.0, 3.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=4,t=27), q_cost = (0.0, 0.0, 18.0, 3.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=27) -- (v=3,t=28), h_cost = (2.0, 0.0, 20.0, 4.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=27) -- (v=4,t=28), h_cost = (1.0, 0.0, 18.0, 3.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=4,t=27) -- (v=8,t=28), h_cost = (0.0, 0.0, 18.0, 2.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=8,t=28), q_cost = (0.0, 0.0, 18.0, 2.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=28) -- (v=4,t=29), h_cost = (2.0, 0.0, 20.0, 3.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=28) -- (v=7,t=29), h_cost = (2.0, 0.0, 20.0, 3.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=28) -- (v=8,t=29), h_cost = (1.0, 0.0, 18.0, 2.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=8,t=28) -- (v=12,t=29), h_cost = (0.0, 0.0, 18.0, 1.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=12,t=29), q_cost = (0.0, 0.0, 18.0, 1.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=12,t=29) -- (v=8,t=30), h_cost = (2.0, 0.0, 20.0, 2.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=12,t=29) -- (v=11,t=30), h_cost = (2.0, 0.0, 20.0, 2.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=12,t=29) -- (v=12,t=30), h_cost = (1.0, 0.0, 18.0, 1.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=12,t=29) -- (v=16,t=30), h_cost = (0.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=16,t=30), q_cost = (0.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 7
[ logger ](path_planning.jl-434): moved 15 to closed set, moved [16] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([16, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   16 => COLLECT(1,4,16)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: COLLECT(1,4,16)
    cache.tF[v]: 30
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: COLLECT(1,4,16)
    agent_idx:     1
    goal:          (v=16,t=30)

[ logger ](a_star.jl-15): A*: start state: (v=16,t=30)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 16 to closed set, moved [17] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 30

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 16, 11, 7, 10, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([17, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   17 => CARRY(1,4,16->15)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: CARRY(1,4,16->15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: CARRY(1,4,16->15)
    agent_idx:     1
    goal:          (v=15,t=31)

[ logger ](a_star.jl-15): A*: start state: (v=16,t=30)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=16,t=30), q_cost = (30.0, 0.0, 18.0, 0.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=16,t=30) -- (v=12,t=31), h_cost = (2.0, 0.0, 21.0, 2.0, -31.0)
[ logger ](a_star.jl-31): A*: exploring (v=16,t=30) -- (v=15,t=31), h_cost = (0.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-31): A*: exploring (v=16,t=30) -- (v=16,t=31), h_cost = (1.0, 0.0, 19.0, 1.0, -31.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=15,t=31), q_cost = (0.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 2
[ logger ](path_planning.jl-434): moved 17 to closed set, moved [18] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([2, 16, 11, 7, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([6, 18])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
    v =   18 => DEPOSIT(1,4,15)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: DEPOSIT(1,4,15)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: DEPOSIT(1,4,15)
    agent_idx:     1
    goal:          (v=15,t=31)

[ logger ](a_star.jl-15): A*: start state: (v=15,t=31)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](path_planning.jl-434): moved 18 to closed set, moved [9, 19] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](path_planning.jl-434): moved 9 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([19, 6])
    node_queue:   DataStructures.PriorityQueue(6 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =   19 => GO(1,15->-1)
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,15->-1)
    cache.tF[v]: 31
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-723): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(1,15->-1)
    agent_idx:     1
    goal:          (v=-1,t=31)

[ logger ](a_star.jl-15): A*: start state: (v=15,t=31)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=15,t=31), q_cost = (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (31.0, 0.0, 19.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 1
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 31. Extending terminal node GO(1,15->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-434): moved 19 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]
    cache.tF: [0, 2, 0, 18, 10, 18, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([18, 2, 16, 11, 7, 9, 10, 19, 17, 8, 4, 3, 5, 20, 13, 14, 15, 12, 1])
    active_set:   Set([6])
    node_queue:   DataStructures.PriorityQueue{Int64,Tuple{Int64,Float64},Base.Order.ForwardOrdering}()
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20
    t0:           [    0    0    0   10    0   18    2   24   31    0   24   21   21   24   24   30   30   31   31    0]
    tF:           [    0    2    0   18   10   18   21   24   31    0   24   21   24   24   30   30   31   31   31    0]
    slack:        [  0.0  0.0  Inf  Inf  Inf  Inf  0.0  6.0  0.0 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 21.0]
    local_slack:  [  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0  Inf 21.0  6.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0]
active task nodes:
    v =    6 => GO(2,13->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(2,13->-1)
    cache.tF[v]: 18
    maximum(env.cache.tF): 31

[ logger ](path_planning.jl-723): BUILD ENV: setting goal_vtx = -1, t = maximum(cache.tF) = 31
[ logger ](a_star.jl-13): A*: entering...
[ logger ](a_star.jl-14): A*: env: PCCBSEnv:
    schedule_node: GO(2,13->-1)
    agent_idx:     2
    goal:          (v=-1,t=31)

[ logger ](a_star.jl-15): A*: start state: (v=13,t=18)
[ logger ](pc_tapf_solvers.jl-78): A* iter 1: s = (v=13,t=18), q_cost = (18.0, 0.0, 0.0, 0.0, -18.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=18) -- (v=9,t=19), h_cost = (0.0, 0.0, 1.0, 0.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=18) -- (v=13,t=19), h_cost = (0.0, 0.0, 0.0, 0.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=18) -- (v=14,t=19), h_cost = (0.0, 0.0, 1.0, 0.0, -19.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 2: s = (v=13,t=19), q_cost = (0.0, 0.0, 0.0, 0.0, -19.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=19) -- (v=9,t=20), h_cost = (0.0, 1.0, 1.0, 0.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=19) -- (v=13,t=20), h_cost = (0.0, 0.0, 0.0, 0.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=19) -- (v=14,t=20), h_cost = (0.0, 0.0, 1.0, 0.0, -20.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 3: s = (v=13,t=20), q_cost = (0.0, 0.0, 0.0, 0.0, -20.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=20) -- (v=9,t=21), h_cost = (0.0, 1.0, 1.0, 0.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=20) -- (v=13,t=21), h_cost = (0.0, 1.0, 0.0, 0.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=13,t=20) -- (v=14,t=21), h_cost = (0.0, 0.0, 1.0, 0.0, -21.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 4: s = (v=14,t=21), q_cost = (0.0, 0.0, 1.0, 0.0, -21.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=21) -- (v=10,t=22), h_cost = (0.0, 0.0, 2.0, 0.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=21) -- (v=13,t=22), h_cost = (0.0, 0.0, 2.0, 0.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=21) -- (v=14,t=22), h_cost = (0.0, 0.0, 1.0, 0.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=21) -- (v=15,t=22), h_cost = (0.0, 0.0, 2.0, 0.0, -22.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 5: s = (v=14,t=22), q_cost = (0.0, 0.0, 1.0, 0.0, -22.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=22) -- (v=10,t=23), h_cost = (0.0, 0.0, 2.0, 0.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=22) -- (v=13,t=23), h_cost = (0.0, 0.0, 2.0, 0.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=22) -- (v=14,t=23), h_cost = (0.0, 0.0, 1.0, 0.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=22) -- (v=15,t=23), h_cost = (0.0, 0.0, 2.0, 0.0, -23.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 6: s = (v=14,t=23), q_cost = (0.0, 0.0, 1.0, 0.0, -23.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=23) -- (v=10,t=24), h_cost = (0.0, 0.0, 2.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=23) -- (v=13,t=24), h_cost = (0.0, 0.0, 2.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=23) -- (v=14,t=24), h_cost = (0.0, 0.0, 1.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=23) -- (v=15,t=24), h_cost = (0.0, 0.0, 2.0, 0.0, -24.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 7: s = (v=14,t=24), q_cost = (0.0, 0.0, 1.0, 0.0, -24.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=24) -- (v=10,t=25), h_cost = (0.0, 0.0, 2.0, 0.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=24) -- (v=13,t=25), h_cost = (0.0, 0.0, 2.0, 0.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=24) -- (v=14,t=25), h_cost = (0.0, 0.0, 1.0, 0.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=24) -- (v=15,t=25), h_cost = (0.0, 0.0, 2.0, 0.0, -25.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 8: s = (v=14,t=25), q_cost = (0.0, 0.0, 1.0, 0.0, -25.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=25) -- (v=10,t=26), h_cost = (0.0, 0.0, 2.0, 0.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=25) -- (v=13,t=26), h_cost = (0.0, 0.0, 2.0, 0.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=25) -- (v=14,t=26), h_cost = (0.0, 0.0, 1.0, 0.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=25) -- (v=15,t=26), h_cost = (0.0, 0.0, 2.0, 0.0, -26.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 9: s = (v=14,t=26), q_cost = (0.0, 0.0, 1.0, 0.0, -26.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=26) -- (v=10,t=27), h_cost = (0.0, 0.0, 2.0, 0.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=26) -- (v=13,t=27), h_cost = (0.0, 0.0, 2.0, 0.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=26) -- (v=14,t=27), h_cost = (0.0, 0.0, 1.0, 0.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=26) -- (v=15,t=27), h_cost = (0.0, 0.0, 2.0, 0.0, -27.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 10: s = (v=14,t=27), q_cost = (0.0, 0.0, 1.0, 0.0, -27.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=27) -- (v=10,t=28), h_cost = (0.0, 0.0, 2.0, 0.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=27) -- (v=13,t=28), h_cost = (0.0, 0.0, 2.0, 0.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=27) -- (v=14,t=28), h_cost = (0.0, 0.0, 1.0, 0.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=27) -- (v=15,t=28), h_cost = (0.0, 0.0, 2.0, 0.0, -28.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 11: s = (v=14,t=28), q_cost = (0.0, 0.0, 1.0, 0.0, -28.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=28) -- (v=10,t=29), h_cost = (0.0, 0.0, 2.0, 0.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=28) -- (v=13,t=29), h_cost = (0.0, 0.0, 2.0, 0.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=28) -- (v=14,t=29), h_cost = (0.0, 0.0, 1.0, 0.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=28) -- (v=15,t=29), h_cost = (0.0, 0.0, 2.0, 0.0, -29.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 12: s = (v=14,t=29), q_cost = (0.0, 0.0, 1.0, 0.0, -29.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=29) -- (v=10,t=30), h_cost = (0.0, 0.0, 2.0, 0.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=29) -- (v=13,t=30), h_cost = (0.0, 0.0, 2.0, 0.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=29) -- (v=14,t=30), h_cost = (0.0, 0.0, 1.0, 0.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=29) -- (v=15,t=30), h_cost = (0.0, 0.0, 2.0, 0.0, -30.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 13: s = (v=14,t=30), q_cost = (0.0, 0.0, 1.0, 0.0, -30.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=30) -- (v=10,t=31), h_cost = (0.0, 0.0, 2.0, 0.0, -31.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=30) -- (v=13,t=31), h_cost = (0.0, 0.0, 2.0, 0.0, -31.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=30) -- (v=14,t=31), h_cost = (0.0, 0.0, 1.0, 0.0, -31.0)
[ logger ](a_star.jl-31): A*: exploring (v=14,t=30) -- (v=15,t=31), h_cost = (0.0, 1.0, 2.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-78): A* iter 14: s = (v=14,t=31), q_cost = (0.0, 0.0, 1.0, 0.0, -31.0)
[ logger ](a_star.jl-23): A*: returning optimal path with cost (31.0, 0.0, 1.0, 0.0, -31.0)
[ logger ](pc_tapf_solvers.jl-257): A* iterations = 14
[ logger ](pc_tapf_solvers.jl-260): ISPS: length(path) = 31. Extending terminal node GO(2,13->-1) to 31
[ logger ](pc_tapf_solvers.jl-264): ISPS: length(path) = 31. maximum(cache.tF) = 31
[ logger ](path_planning.jl-434): moved 6 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [0, 2, 0, 18, 10, 31, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
[ logger ](pc_tapf_solvers.jl-270): ISPS: after update_route_plan! maximum(cache.tF) = 31
[ logger ](pc_tapf_solvers.jl-343): ISPS:
    routes:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  14  14  14  14  14  14  14  14  14  14  14  ]
    cache.tF: [0, 2, 0, 18, 10, 31, 21, 24, 31, 0, 24, 21, 24, 24, 30, 30, 31, 31, 31, 0]
    cache.tF[v]: 31

[ logger ](cbs.jl-31): CBS: iter 0 - node Int64[] - Current paths:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   3   4   8   12  16  15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  14  14  14  14  14  14  14  14  14  14  14  ]

[ logger ](cbs.jl-36): CBS: constraints in node Int64[]:

[ logger ](cbs.jl-50): Optimal solution found by CBS! Cost = (31.0, 0.0, 20.0, 0.0, -62.0)
[ logger ](pc_tapf_solvers.jl-556): NBS: Reached 1-iteration limit.
[ logger ](replanning.jl-604): Stage 2 - route planner iterations: 0
[ logger ](replanning.jl-597): REPLANNING: Stage 3
Academic license - for non-commercial use only
Academic license - for non-commercial use only
[ logger ](task_assignment_solvers.jl-1117): Assignment: Adding edges
    GO(1,3->16) → COLLECT(1,4,16)
    GO(1,11->9) → COLLECT(1,5,9)
    GO(1,15->8) → COLLECT(1,6,8)
    GO(1,11->7) → COLLECT(1,7,7)

[ logger ](path_planning.jl-434): moved 12 to closed set, moved [10] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](path_planning.jl-434): moved 10 to closed set, moved [13] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](path_planning.jl-434): moved 5 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](path_planning.jl-434): moved 32 to closed set, moved [18] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](path_planning.jl-434): moved 18 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](path_planning.jl-434): moved 33 to closed set, moved [17] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](path_planning.jl-434): moved 17 to closed set, moved Int64[] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](path_planning.jl-434): moved 3 to closed set, moved [6] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](path_planning.jl-434): moved 6 to closed set, moved [1] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](path_planning.jl-434): moved 1 to closed set, moved [11] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](path_planning.jl-434): moved 11 to closed set, moved [14] to active set
[ logger ](path_planning.jl-435): cache.tF[v] = [18, 7, 0, 6, 0, 10, 7, 10, 7, 2, 26, 0, 6, 26, 16, 20, 0, 0, 16, 14, 16, 16, 17, 10, 12, 12, 14, 17, 20, 20, 20, 0, 0]
[ logger ](pc_tapf_solvers.jl-334): SearchEnv:
cache: PlanningCache:
    closed_set:   Set([12, 18, 32, 11, 10, 17, 6, 3, 5, 33, 1])
    active_set:   Set([13, 14])
    node_queue:   DataStructures.PriorityQueue(14 => (1, Inf))
               v:      1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33
    t0:           [   10    7    0    6    0    0    7    7    6    0   18    0    2   26   16   20    0    0   16   14   14   16   16   10   10   12   12   17   17   20   20    0    0]
    tF:           [   18    7    0    6    0   10    7   10    7    2   26    0    6   26   16   20    0    0   16   14   16   16   17   10   12   12   14   17   20   20   20    0    0]
    slack:        [  Inf  0.0  Inf  0.0  6.0  Inf  0.0  Inf  0.0  0.0  Inf  0.0  0.0  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf  Inf]
                  [  Inf  0.0  Inf  0.0  6.0  Inf  Inf  0.0  0.0  0.0  Inf  0.0  0.0  Inf  1.0  0.0 14.0 10.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf 10.0 14.0]
    local_slack:  [  0.0  0.0  0.0  0.0  6.0  0.0  Inf  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  Inf 14.0 10.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
                  [  0.0  0.0  0.0  0.0  6.0  0.0  Inf  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  Inf 14.0 10.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  Inf  0.0  0.0]
active task nodes:
    v =   13 => GO(1,3->16)
    v =   14 => GO(2,14->-1)
route_plan: LowLevelSolution:
   T:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26
   1: [1   1   1   1   1   1   1   1   1   1   1   2   3   4   8   7   6   6   6   5   9   13  9   5   1   2   15  ]
   2: [13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  14  14  14  14  14  14  ]


[ logger ](pc_tapf_solvers.jl-335): ISPS:
    schedule_node: GO(1,3->16)
    cache.tF[v]: 6
    maximum(env.cache.tF): 26
